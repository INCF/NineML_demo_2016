# encoding: utf-8
"""
Plot colour plots of spike train statistics as a function of
the parameters g and eta for the Brunel (2000) model

"""

from __future__ import division, print_function
import os
import argparse
import numpy as np
import matplotlib.pyplot as plt
from quantities import Quantity
from neo import get_io
from elephant.statistics import mean_firing_rate, cv, isi
import pandas


parser = argparse.ArgumentParser()
parser.add_argument("directory",
                    help="directory containing data generated by running sweep.py")
config = parser.parse_args()

results_dir = config.directory

statistics_file = os.path.join(results_dir, "statistics.csv")

if os.path.exists(statistics_file):
    # read the previously calculated spike train statistics from file
    data = pandas.read_csv(statistics_file,
                           #names=("g", "eta", "output_file"),
                           delim_whitespace=True)
else:
    # for each data file, read the spike trains and calculate the metrics
    data = pandas.read_csv(os.path.join(results_dir, "sweeps.csv"),
                           names=("g", "eta", "output_file"),
                           delim_whitespace=True)

    for idx, row in data.iterrows():
        data_block = get_io(row["output_file"]).read()[0]
        spiketrains = data_block.segments[0].spiketrains
        data.ix[idx, "spike_counts"] = sum(st.size for st in spiketrains)
        # calculate mean firing rate
        rates = [mean_firing_rate(st) for st in spiketrains]
        data.ix[idx, "firing_rate"] = Quantity(rates, units=rates[0].units).rescale("1/s").mean()
        # calculate coefficient of variation of the inter-spike interval
        cvs = [cv(isi(st)) for st in spiketrains if st.size > 1]
        if len(cvs) > 0:
            data.ix[idx, "cv_isi"] = sum(cvs)/len(cvs)
        else:
            data.ix[idx, "cv_isi"] = 0
        # calculate global cross-correlation
        ## TODO

    print(data)

    # save statistics to file
    data.to_csv(os.path.join(results_dir, "statistics.csv"),
                sep=" ", index=False)


# build data structures for plotting
gvec = np.sort(data["g"].unique())
etavec = np.sort(data["eta"].unique())
print(gvec, etavec)
z = {
    "firing_rate": np.zeros((etavec.size, gvec.size)),
    "spike_counts": np.zeros((etavec.size, gvec.size), dtype=int),
    "cv_isi": np.zeros((etavec.size, gvec.size)),
    "xcorr": np.zeros((etavec.size, gvec.size))
}

for idx, row in data.iterrows():
    # convert g and eta to i and j
    j = np.argwhere(gvec == row["g"])[0]
    i = np.argwhere(etavec == row["eta"])[0]
    for name in ("firing_rate", "cv_isi"):
        z[name][i, j] = row[name]

# plot figure
x, y = np.meshgrid(gvec, etavec)
plt.figure(1)
plt.subplot(2, 2, 1)
plt.pcolormesh(x, y, z["firing_rate"], cmap='RdBu', vmin=0, vmax=z["firing_rate"].max())
plt.title('Firing rate')
plt.ylabel("eta")
plt.xlabel("g")
# set the limits of the plot to the limits of the data
plt.axis([x.min(), x.max(), y.min(), y.max()])
plt.colorbar()
plt.subplot(2, 2, 2)
plt.pcolormesh(x, y, z["cv_isi"], cmap='RdBu', vmin=0, vmax=z["cv_isi"].max())
plt.title('CV (ISI)')
plt.axis([x.min(), x.max(), y.min(), y.max()])
plt.colorbar()
plt.subplot(2, 2, 3)

plt.savefig(os.path.join(results_dir, "brunel_network_phase_plots.png"))
